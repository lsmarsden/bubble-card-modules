import re
from typing import List, Union

import jinja2
from json_schema_for_humans.md_template import MarkdownTemplate, escape_for_table
from json_schema_for_humans.schema.schema_node import SchemaNode


def clean_menu_link(menu: str) -> str:
    # transform menu heading into its link to use linking
    # this can't be used for property tables right now since
    # the tables are rendered before the headings, so we don't have
    # access to the links. This means property table links don't work
    menu = re.sub(r"[#.`]", "", menu)
    menu = menu.replace(" ", "-")
    if menu.startswith("-"):
        menu = menu[1:]
    return menu.lower()


class CustomMarkdownTemplate(MarkdownTemplate):
    def __init__(self, config):
        super().__init__(config)

    def register_jinja(self, env: jinja2.Environment):
        super().register_jinja(env)

    def property_link(self, prop: SchemaNode) -> str:
        return self.format_link(escape_for_table(prop.property_name), prop.html_id)

    def properties_table(self, schema: SchemaNode) -> List[List]:
        properties = []
        for sub_property in schema.iterate_properties:
            row = [
                "+ " + sub_property.property_name if sub_property.is_required_property else "- " + self.property_link(
                    sub_property),
                sub_property.type_name,
                sub_property.default_value or "-",
                sub_property.title or sub_property.description or "-"]

            properties.append([escape_for_table(cell) for cell in row])

        if properties:
            headers = ["Property", "Type", "Default", "Description"]
            properties.insert(0, headers)

        return properties

    def type_info_table(self, schema: SchemaNode) -> List[List]:

        schema_type = schema.type_name
        default_value = schema.default_value or "-"
        description = schema.description or "-"

        type_info = [
            ["**Type**", "**Default**", "**Description**"],
            [schema_type, default_value, description]
        ]

        return type_info

    def heading(self, title: str, depth: int, html_id: Union[bool, str] = False, nested: bool = False) -> str:
        if depth == 0:
            # If we process multiple files, this needs to be reset manually
            # because there is only one instance of this class
            self.toc = {}
            self.auto_generated_heading = 0

        if not html_id:
            self.auto_generated_heading = self.auto_generated_heading + 1
            html_id = f"autogenerated_heading_{self.auto_generated_heading}"
        if not (title and title.strip()):
            title = "Auto generated title"
        else:
            title = title.strip()

            # reset heading depth greater than current depth
        for curDepth in range(
                depth + 1, max(int(heading) for heading in self.headings) + 1 if self.headings else depth + 1
        ):
            self.headings.pop(curDepth, None)

            # compute heading, for each depth get last level, and increment level of asked depth
        heading_numbers = ""
        for curDepth in range(0, depth + 1):
            if curDepth in self.headings:
                if curDepth == depth:
                    self.headings[curDepth] = self.headings[curDepth] + 1
            else:
                self.headings[curDepth] = 1
            if curDepth != 0:
                heading_numbers += f"{self.headings[curDepth]}."

        # markdown menu depth
        menu = "#" * min((depth + 1), 6)
        if nested:
            menu = "<strong>"

        # generate markdown title with anchor (except if depth 0)
        if depth == 0:
            menu += f" {title}"
        else:
            if self.config.template_md_options.get("show_heading_numbers"):
                menu += f' {heading_numbers} {title}'
            else:
                menu += f' {title}'

        menu_link = clean_menu_link(menu)

        # store current heading in toc
        toc_menu = f"[{title}](#{menu_link})"
        if self.config.template_md_options.get("show_heading_numbers"):
            toc_menu = f"[{heading_numbers} {title}](#{menu_link})"
        self.toc[heading_numbers] = {"depth": depth, "menu": toc_menu}

        if nested:
            menu += "</strong>"
        return menu
